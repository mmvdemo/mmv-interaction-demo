<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Zoom</title>
    </head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <body>
        <canvas id="mycanvas" />
        <script type="text/javascript">
        //load data
        let nodeCnt = 50;
        let timeStart = 2012, timeEnd = 2019;
        
        //color
        let backgroundColor = 0x707B7C;
        let headColor = 0x85C1E9; 
        let nodeColor = 0x1ABC9C;
        let selectColor = 0xE74C3C;
        let lineColor = 0x2E4053;
        //parameters
        let stageWidth = 800, stageHeight = 800;
        let tableWidth = nodeCnt, tableHeight = nodeCnt;
        let focalScale = 4;
        let maxScale = 4;
        let stepWidth = stageWidth/tableWidth,stepHeight = stageHeight/tableHeight;
        let chartRatio=0.8;
        let nodeRadius =0.2; 
        let showChart = false;
        //init app
        const container = new PIXI.Container();
        let canvas = document.getElementById("mycanvas");
        let app = new PIXI.Application({width:stageWidth, height:stageHeight, antialias:true, view:canvas});
        app.renderer.backgroundColor = backgroundColor;
        //document.body.appendChild(app.view);
        app.stage.interactive = true;
        app.stage.addChild(container);
        //generate background texture
        let background = new PIXI.Graphics();
        for(let i=0;i<tableWidth;i++) {
            for(let j=0;j<tableHeight;j++) {
                let value = getValue(timeEnd,i,j);
                let colorStr = d3.interpolateYlGn(value);
                let color = rgbStrToHex(colorStr);
                background.beginFill(color);
                background.drawRect(i*stepWidth*maxScale,j*stepHeight*maxScale,(i+1)*stepWidth*maxScale,(j+1)*stepHeight*maxScale);
                background.endFill();
            }
        }
        const backgroundTexture =app.renderer.generateTexture(background);
        //generate line chart containers
        let linecharts = drawLineCharts();
        
        window.onload = loadTable();

        let d3canvas = d3.select("#mycanvas");
        d3canvas.call(d3.zoom().scaleExtent([1, 8]).on("zoom", zoom));
        function zoom() {
            //console.log(parseInt(PIXI.Ticker.shared.FPS)+' FPS');
            var x = d3.event.transform.x;
            var y = d3.event.transform.y;
            var scale = d3.event.transform.k;
            
            console.log("hovering on (row,column): ("+Math.floor((d3.mouse(canvas)[0]-x)/scale/stepWidth)+ ', '+Math.floor((d3.mouse(canvas)[1]-y)/stepHeight/scale)+')');
            console.log('');
            container.x = x;
            container.y = y;
            container.scale.x = scale;
            container.scale.y = scale;
            if(scale>focalScale && showChart ==false){
                showChart=true;
                linecharts.visible = true;
            } else if(scale<focalScale && showChart ==true) {
                showChart = false;
                linecharts.visible = false;
            }
        }
        function loadTable() {
            let backgroundSprite = new PIXI.Sprite(backgroundTexture);
            backgroundSprite.scale.x = 1/maxScale;
            backgroundSprite.scale.y = 1/maxScale;
            linecharts.scale.x = 1/maxScale;
            linecharts.scale.y = 1/maxScale;
            backgroundSprite.x = 0;
            backgroundSprite.y = 0;
            linecharts.visible = false;
            container.addChild(backgroundSprite);
            container.addChild(linecharts);
        }
        function rgbStrToHex(s) {
            let pat = new RegExp("\\d+","g");
            let numbers = s.match(pat);
            let color = 0x0;
            for (var i=0;i<3;i++) {
                color += Number(numbers[i])*Math.pow(256,2-i);
            }
            return color; 
        }
        function drawLineCharts() {
            let linecharts = new PIXI.Container();
            let chartHeight = stepHeight*chartRatio*maxScale;
            let chartWidth = stepWidth*chartRatio*maxScale;
            let originW = (stepWidth*maxScale-chartWidth)/2;
            let originH = (stepHeight*maxScale-chartHeight)/2;
            for(let i=0;i<tableWidth;i++) {
                for(let j=0;j<tableHeight;j++) {
                    let graphics = new PIXI.Graphics();
                    graphics.x = 0;
                    graphics.y = 0;
                    let translateW = i*stepWidth*maxScale;
                    let translateH = j*stepHeight*maxScale;
                    
                    graphics.lineStyle(2,lineColor,1)
                                .moveTo(0,0+chartHeight)
                                .lineTo(0+chartWidth,0+chartHeight);
                    graphics.lineStyle(2,lineColor,1)
                                .moveTo(0,0+chartHeight)
                                .lineTo(0,0);

                    let timeLen = timeEnd-timeStart;
                    let lastX=-1,lastY=-1;
                    for(let t=timeStart;t<=timeEnd;t++) {
                        let value = getValue(t,i,j);
                        let xPos = chartWidth*(t-timeStart)/timeLen;
                        let yPos = chartHeight*(1-value);
                        graphics.beginFill(nodeColor);
                        graphics.drawCircle(xPos,yPos,nodeRadius*maxScale);
                        graphics.endFill();
                        if(lastX>=0) {
                            graphics.lineStyle(1,lineColor,1)
                                .moveTo(lastX,lastY)
                                .lineTo(xPos,yPos);
                        }
                        lastX=xPos;
                        lastY=yPos;
                    } 
                    let texture = app.renderer.generateTexture(graphics);
                    let sprite = new PIXI.Sprite(texture);
                    sprite.x = translateW+originW;
                    sprite.y = translateH+originH;
                    linecharts.addChild(sprite);
                }
            }
            return linecharts;
        }
        function getValue(timeIdx,i,j) {
            return Math.random();
        }

        </script>
    </body>
</html>
